# Daily Gift Store

---
## 프로젝트 소개
- 목적: 매일매일 선물을 줄 수 있는 스토어 서비스
- 기간: 2024.06.19 ~ 진행 중
- 인원: 1명
- [프로젝트 기록](https://devseopchan.notion.site/018fb2252bfd4e43b29f7b1cc03a602b)

## 기술 스택, 툴
- 언어: TypeScript
- UI 프레임워크: React
- 빌드 툴: Vite
- UI: Tailwind CSS, shadcn/ui
- 상태관리: React Context API, react Query
- DB: Firebase
- 기타: Tailwind CSS, React hook form
- other tools: Github, SourceTree

---
## 기술 스택 선택 이유
### TypeScript 선정 이유
* **사용 경험**: 이미 사용해본 언어로 러닝커브가 낮음
* **정적 타입 언어**: 타입 에러를 런타임이 아닌 컴파일 타임에 발견 가능
* **코드 가이드 및 자동 완성**: 코드 가이드 및 자동 완성을 통해 개발 생산성 향상
* **타입 추론**: 타입 추론을 통해 코드 가독성 향상
* **타입 안정성**: 타입 안정성을 통해 코드 품질 향상
* **리팩토링**: 리팩토링 시 타입 정의를 통해 안전하게 코드 변경 가능

* 단점:
  * 타입 정의: 타입 정의를 위한 추가적인 코드 작성이 필요
    * 타입 정의 오버헤드: 타입 정의로 인해 코드 작성 시간이 늘어날 수 있음

### React 선정 이유
* 이미 사용해본 React: 러닝커브가 낮다
* 가장 많은 사용자와 커뮤니티: 많은 라이브러리와 플러그인 지원 

### React vs Vue.js vs Angular vs Svelte (+ Next.js)
<details>
<summary>상세 비교</summary>
<div markdown="1">

공통점: 
* SPA, Web-App
* 화면 전환이 빠르다

차이점:
* 트렌드 [2024-06-19]: React > Next.js > Vue.js > Angular > Svelt
* React: 가장 많은 사용자, 커뮤니티, 라이브러리, 플러그인이 존재
  ![스크린샷 2024-06-19 오전 11.54.00.png](..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Frc%2Fd1wjtcm51xs8tcpkyg47v_w40000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_OfAhxw%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-06-19%20%EC%98%A4%EC%A0%84%2011.54.00.png)

공통점:
SPA (Single Page Application) 및 Web-App 개발에 사용
화면 전환이 빠름
차이점 및 장단점 비교:
1. React 
   * 장점
     * 가장 많은 사용자와 커뮤니티: 많은 라이브러리와 플러그인 지원
     * Virtual DOM: 효율적인 업데이트 및 렌더링
     * JSX: HTML과 JavaScript의 조합으로 높은 표현력
     * React Hooks: 함수형 컴포넌트에서 상태 관리 및 사이드 이펙트 처리 간편
   * 단점:
     * 학습 곡선: JSX와 Hook의 개념을 익히는데 시간이 걸릴 수 있음
     * 필수 라이브러리: 상태 관리(Redux 등), 라우팅(React Router 등)을 위해 추가 라이브러리 필요
2. Vue.js
   * 장점:
     * 쉽고 직관적인 문법: 초보자에게 적합한 학습 곡선
     * 템플릿 문법: HTML 기반으로 친숙함
     * Reactive 데이터 바인딩: 데이터와 UI의 자동 동기화
     * Vue CLI: 프로젝트 초기 설정 및 개발 편의성 제공
   * 단점:
     * 규모 확장 어려움: 대형 프로젝트에서는 복잡성 증가 가능
     * 커뮤니티 규모: React에 비해 작음
     * 유연성: 자유도가 높아 일관성 유지가 어려울 수 있음
3. Angular
   * 장점
     * 완전한 프레임워크: 모든 것을 갖춘 종합적인 솔루션
     * TypeScript 사용: 정적 타입 언어로 코드 안정성 향상
     * 양방향 데이터 바인딩: 모델과 뷰의 자동 동기화
     * 강력한 CLI: 코드 생성, 테스트 등 다양한 기능 제공
   * 단점:
     * 학습 곡선: 복잡한 개념과 구조로 인해 배우기 어려움
     * 무거운 프레임워크: 초기 로드 시간이 길어질 수 있음
     * 변경 관리 어려움: 버전 업데이트 시 코드 호환성 문제 발생 가능
4. Svelte
   * 장점
     * 컴파일러 기반: 런타임이 필요 없어 더 작은 번들 사이즈와 빠른 실행 속도
     * 간결한 문법: 코드 작성이 간편하고 직관적
     * Reactiveness 내장: 상태 변화에 따른 자동 UI 업데이트
   * 단점:
     * 작은 커뮤니티: 지원 리소스와 라이브러리 부족
     * 생태계 미성숙: 아직 안정화되지 않은 부분이 있을 수 있음
     * 러닝 커브: 새로운 개념과 방식에 대한 학습 필요
5. Next.js (React 기반)
   * 장점:
     * 서버사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG): SEO 및 초기 로딩 속도 향상
     * 파일 기반 라우팅: 쉬운 라우팅 설정
     * API 라우트: 서버리스 함수로 API 구성 가능
     * 최적화 기능: 자동 코드 분할, 이미지 최적화 등 내장
   * 단점:
     * React에 종속적: React를 먼저 이해해야 함
     * 추가 학습 필요: Next.js의 고유 기능을 익혀야 함
     * 프로젝트 설정 복잡성: 복잡한 설정이나 구성 필요할 수 있음
</div>
</details>

### Vite 선정 이유
* **소규모 프로젝트**: 빠른 개발 속도와 간단한 설정이 가능한 부분이 적합
* **빠른 빌드 속도**: 이미 사용해본 Webpack (CRA)는 빌드 속도가 느림
  * Vite: 빠른 빌드 속도, 라이브 리로드, 모듈 번들링 -> webpack, rollup, CRA에 비해 최대 10배 빠름
    * esbuild를 이용해 종속성을 미리 묶음
    * esbuild: Go로 작성된 빠른 번들러, Go언어에 특화된 병렬처리로 빠른 번들링 가능

### Webpack vs Vite
<details>
<summary>상세 비교</summary>
<div markdown="1">

공통점:
* 모듈 번들링: 자바스크립트, CSS, 이미지 등 다양한 파일을 번들링
* 라이브 리로드: 코드 수정 시 자동으로 브라우저 새로고침
* 환경 설정: 설정 파일을 통해 빌드, 번들링, 로더, 플러그인 설정 가능

차이점:

| 특징               | Webpack                                                                                 | Vite                                                                                   |
|------------------|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
| **빌드 속도**       | 초기 빌드와 재빌드 속도가 느릴 수 있음                                                            | 매우 빠른 개발 서버 및 HMR 제공                                                          |
| **설정 복잡성**     | 매우 유연하지만 설정이 복잡할 수 있음                                                               | 간단한 기본 설정 제공, 필요한 경우에만 추가 설정                                              |
| **생태계**         | 광범위한 로더와 플러그인, 대규모 커뮤니티 지원                                                        | 상대적으로 작은 플러그인 생태계, 최신 브라우저 기능 활용                                            |
| **호환성**         | 거의 모든 JavaScript 프레임워크와 라이브러리와 잘 호환됨                                                 | 최신 브라우저 기능을 활용하여 구형 브라우저 지원이 필요한 경우 추가 설정 필요                                 |
| **성능 최적화**     | 코드 스플리팅, 트리 쉐이킹 등 성능 최적화 기능 제공                                                    | Rollup 기반 빌드 도구로 빠르고 효율적인 프로덕션 빌드 제공                                          |
| **플러그인 시스템**  | 다양한 플러그인으로 기능 확장 가능                                                                | Rollup 기반 플러그인 시스템 사용, 플러그인 생태계가 Webpack보다 작음                                      |

* 결론
  * Webpack: 대규모 프로젝트나 복잡한 요구사항이 있는 프로젝트에서 유리, 유연성과 확장성이 뛰어나지만, 설정이 복잡할 수 있음
  * Vite: 빠른 개발 속도와 간단한 설정이 필요한 소규모에서 중규모 프로젝트에 적합, 최신 브라우저 기능을 활용하며, 빠른 HMR을 제공
</div>
</details>

### Tailwind CSS 선정 이유
* **정적 CSS 클래스**: 이전에 styled-components(CSS-in-JS)를 사용했는데, 런타임에 JavaScript를 실행해야 해 성능 저하가 있었음
  * tailwind css는 정적 CSS 클래스를 사용해 성능 저하가 없음
* **클래스 기반 스타일링**: 빠르게 CSS 작성 가능, Tailwind 설정 파일을 통해 테마와 스타일을 쉽게 커스터마이징 가능
  * 4주라는 짧은 개발 기간으로 유틸리티 클래스를 통한 빠른 스타일링이 필요

* 단점
  * 유틸리티 클래스: 클래스 기반 스타일링으로 인해 HTML 코드가 복잡해질 수 있음
  * 커스터마이징: 기본 테마를 벗어나 커스터마이징이 어려울 수 있음
  * 디자인 시스템: 일관된 디자인 시스템을 유지하기 어려울 수 있음
  * 커스터 마이징, 디자인 시스템 문제는 **shadcn/ui 라이브러리를 사용해 해결**

### CSS-in-JS vs Tailwind CSS vs SCSS
<details>
<summary>상세 비교</summary>
<div markdown="1">

| 특징                        | CSS-in-JS                                                   | Tailwind CSS                                             | SCSS (Sass)                                                  |
|---------------------------|-------------------------------------------------------------|---------------------------------------------------------|--------------------------------------------------------------|
| **Scoped Styles**         | 컴포넌트 단위로 스타일 적용 가능, 전역 네임스페이스 충돌 방지                     | 전역 클래스 네임스페이스 사용, Tailwind 설정으로 관리                         | 전역 네임스페이스 사용, 스타일 충돌 가능                                        |
| **Dynamic Styling**       | JavaScript 변수와 로직을 통한 동적 스타일링 가능                           | 유틸리티 클래스 기반, 동적 스타일링 어려움                                   | 한정된 동적 기능 제공 (변수, 믹스인 등)                                         |
| **Performance**           | 런타임 스타일 생성으로 성능 저하 가능성                                 | 빌드 타임에 컴파일, 성능 최적화                                          | 빌드 타임에 컴파일, 큰 프로젝트에서 빌드 시간 길어질 수 있음                                   |
| **Tooling**               | 기존 CSS 도구와의 통합 제한적                                      | Tailwind 전용 도구 및 설정 파일                                      | 광범위한 커뮤니티 지원 및 도구 제공                                           |
| **Learning Curve**        | 새로운 개념 학습 필요                                          | 유틸리티 클래스 시스템 학습 필요                                     | 기존 CSS에 익숙한 개발자에게 배우기 쉬움                                       |
| **Consistency**           | JavaScript 코드베이스 내에서 일관성 유지 가능                            | 일관된 디자인 시스템 유지 용이                                         | 스타일 모듈화를 통해 일관성 유지 가능                                           |
| **Customizability**       | JavaScript 로직을 통해 높은 유연성 제공                              | Tailwind 설정 파일을 통해 커스터마이징 가능                                | 변수, 믹스인, 함수 등을 통해 커스터마이징 가능                                    |
| **Responsive Design**     | 미디어 쿼리 사용 가능                                           | 유틸리티 클래스 기반으로 반응형 디자인 용이                                | 미디어 쿼리 사용 가능                                                    |

결론
* CSS-in-JS: 동적 스타일링과 컴포넌트 기반 스타일링이 필요할 때 적합
* Tailwind CSS: 유틸리티 클래스를 통한 빠른 스타일링과 일관된 디자인 시스템을 유지하고자 할 때 유리
* SCSS(Sass): 기존 CSS에 익숙하고 확장된 기능을 활용하여 스타일을 모듈화하고 유지보수하고자 할 때 적합

</div>
</details>


### shadcn/ui 선정 이유
* Radix UI와 Tailwind CSS를 사용하여 구축된 재사용 가능한 컴포넌트 모음
  * Radix UI: 접근성과 사용자 경험에 중점을 둔 웹 UI 컴포넌트 컬렉션
  * Tailwind CSS와 함께 사용하면, 스타일링이 용이해짐
  * shadcn/ui: Radix UI의 장점을 기반으로, 추가적인 스타일링과 사용 편의성 제공
* **직접적인 커스터마이제이션**: 컴포넌트 코드를 직접 프로젝트에 통합해, 라이브러리의 제약에서 벗어나 자유롭게 커스터마이즈 가능
* **의존성 최소화**: 별도의 패키지 설치 없이 필요한 컴포넌트만 선택해서 사용 가능
  * 앱의 크기를 줄이고 관리 용이
* **빠른 통합과 사용**: npm과 같은 패키지 매니저를 사용하지 않아, 필요한 컴포넌트를 찾아 바로 사용 가능
* 



### React Context API 선정 이유
* 간단한 글로벌 상태 관리가 필요한 소규모 애플리케이션
* Redux보다 더 간단하고 쉬운 사용법
* 추가적인 외부 라이브러리 없이 React에 내장된 기능을 사용 가능

### React Context API vs Redux vs MobX vs Recoil
<details>
<summary>상세 비교</summary>
<div markdown="1">

| 특징                    | React Context API                              | Redux                                               | MobX                                                | Recoil                                              |
|------------------------|------------------------------------------------|----------------------------------------------------|----------------------------------------------------|----------------------------------------------------|
| **복잡한 상태 관리**     | 어려움                                           | 우수                                                  | 보통                                                  | 우수                                                  |
| **설정 및 사용법**        | 간단함                                           | 복잡                                                  | 간단                                                  | 간단                                                  |
| **성능**                | 많은 상태 업데이트 시 성능 저하 가능                      | 성능 우수                                               | 성능 우수                                               | 성능 우수                                               |
| **러닝 커브**            | 낮음                                             | 높음                                                  | 낮음                                                  | 보통                                                  |
| **미들웨어/확장 기능**    | 제한적                                           | 다양한 미들웨어와 확장 기능 제공                              | 제한적                                                 | 제한적                                                 |
| **디버깅 및 DevTools**   | 기본 지원                                         | Redux DevTools 제공                                    | 디버깅 어려움                                            | 제한적                                                 |
| **비동기 상태 관리**      | 수동으로 구현 필요                                    | Redux Thunk/Saga 등 미들웨어 필요                        | 수동으로 구현 필요                                         | 내장 지원                                                |
| **생태계 및 커뮤니티**    | 비교적 작음                                        | 매우 큼                                                 | 보통                                                   | 성장 중                                                 |
| **학습 곡선**            | 낮음                                             | 높음                                                  | 낮음                                                  | 보통                                                  |

</div>
</details>

### Firebase 선정 이유
* MSW(Mock Service Worker)방식도 있음, MSW도 백엔드를 모킹해서 사용하기 때문에 좋은 방법
* Firebase를 사용해 실제 백엔드를 일부 구축해 사용해보고 싶어서 선택

---
## 코드 컨벤션
### 코드 스타일
* **네이밍 컨벤션**: camelCase
* **타입 정의**: TypeScript 사용
* **폴더 구조**: 컴포넌트, 페이지, 훅, 유틸리티 등 기능별로 폴더 구분
* **폴더명**: 소문자, 띄어쓰기 대신 하이픈(-) 사용
* **파일명**: PascalCase, 파일명은 컴포넌트명과 동일하게 작성
* **상수**: 상수명은 대문자, 띄어쓰기 대신 언더바(_) 사용

---

### 커밋 컨벤션
* **커밋 메시지 형식**: `[<타입>]: <제목>`
  * feat: 새로운 기능 추가
  * fix: 버그 수정
  * docs: 문서 수정
  * style: 코드 포맷팅, 세미콜론 누락, 코드 변경이 없는 경우
  * refactor: 코드 리팩토링
  * test: 테스트 코드, 리팩토링 테스트 코드 추가
  * chore: 빌드 업무 수정, 패키지 매니저 수정

```text
[feat]: 로그인 페이지 추가
[fix]: 로그인 버튼 클릭 시 에러 수정
[docs]: README.md 수정
[style]: 코드 포맷팅
[refactor]: 로그인 페이지 컴포넌트 리팩토링
[test]: 로그인 페이지 테스트 코드 추가
[chore]: package.json 업데이트
```


